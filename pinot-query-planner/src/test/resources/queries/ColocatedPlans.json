{
  "colocated_join_planning_tests": {
    "queries": [
      {
        "description": "Inner join with order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, a.ts, b.col3 FROM a /*+ partitioned (column='col1', partitions='4') */ JOIN b /*+ partitioned (column='col2', partitions='4') */ ON a.col1 = b.col2 ORDER BY a.col1 option(useColocatedJoin=true, queryParallelism=4)",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], ts=[$1], col3=[$3])",
          "\n  LogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n    PinotSortExchange(distribution=[hash=([])], collation=[[0]])",
          "\n      LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n        LogicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[true])",
          "\n            LogicalProject(col1=[$3], ts=[$4])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[true])",
          "\n            LogicalProject(col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[b]])",
          "\n"
        ]
      },
      {
        "description": "Left side of join gets identity exchange",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, a.ts, b.col3 FROM a /*+ partitioned (column='col1', partitions='2') */ JOIN b /*+ partitioned (column='col2', partitions='4') */ ON a.col1 = b.col2 ORDER BY a.col1 option(useColocatedJoin=true, queryParallelism=2)",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], ts=[$1], col3=[$3])",
          "\n  LogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n    PinotSortExchange(distribution=[hash=([])], collation=[[0]])",
          "\n      LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n        LogicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[true])",
          "\n            LogicalProject(col1=[$3], ts=[$4])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[false])",
          "\n            LogicalProject(col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[b]])",
          "\n"
        ]
      },
      {
        "description": "Right side of join gets identity exchange",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, a.ts, b.col3 FROM a /*+ partitioned (column='col1', partitions='2') */ JOIN b /*+ partitioned (column='col2', partitions='4') */ ON a.col1 = b.col2 ORDER BY a.col1 option(useColocatedJoin=true, queryParallelism=4)",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], ts=[$1], col3=[$3])",
          "\n  LogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n    PinotSortExchange(distribution=[hash=([])], collation=[[0]])",
          "\n      LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n        LogicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[false])",
          "\n            LogicalProject(col1=[$3], ts=[$4])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n          PinotExchange(distribution=[hash=([0])], identity=[true])",
          "\n            LogicalProject(col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[b]])",
          "\n"
        ]
      }
    ]
  },
  "exception_throwing_colocated_join_planning_tests": {
    "queries": [
      {
        "description": "Incorrect table",
        "sql": "EXPLAIN PLAN FOR SELECT b.col1 - a.col3 FROM a JOIN c ON a.col1 = c.col3",
        "expectedException": "Error explain query plan for.*"
      }
    ]
  }
}
